{"ast":null,"code":"const block = ['top', 'bottom'];\nconst inline = ['start', 'end'];\n/** Parse a raw anchor string into an object */\n\nexport function parseAnchor(anchor) {\n  let [side, align] = anchor.split(' ');\n\n  if (!align) {\n    align = side === 'top' || side === 'bottom' ? 'start' : side === 'start' || side === 'end' ? 'top' : 'center';\n  }\n\n  return {\n    side,\n    align\n  };\n}\n/** Get an anchor directly opposite, with the same alignment */\n\nexport function oppositeAnchor(anchor) {\n  return {\n    side: {\n      center: 'center',\n      top: 'bottom',\n      bottom: 'top',\n      start: 'end',\n      end: 'start'\n    }[anchor.side],\n    align: anchor.align\n  };\n}\n/** Convert start/end into left/right */\n\nexport function physicalAnchor(anchor, el) {\n  var _map$side, _map$align;\n\n  const {\n    side,\n    align\n  } = anchor;\n  const {\n    direction\n  } = window.getComputedStyle(el);\n  const map = direction === 'ltr' ? {\n    start: 'left',\n    end: 'right'\n  } : {\n    start: 'right',\n    end: 'left'\n  };\n  return ((_map$side = map[side]) != null ? _map$side : side) + ' ' + ((_map$align = map[align]) != null ? _map$align : align);\n}","map":{"version":3,"mappings":"AAAA,MAAMA,KAAK,GAAG,CAAC,KAAD,EAAQ,QAAR,CAAd;AACA,MAAMC,MAAM,GAAG,CAAC,OAAD,EAAU,KAAV,CAAf;AAeA;;AACA,OAAO,SAASC,WAAT,CAAsBC,MAAtB,EAAsC;EAC3C,IAAI,CAACC,IAAD,EAAOC,KAAP,IAAgBF,MAAM,CAACG,KAAPH,CAAa,GAAbA,CAApB;;EACA,IAAI,CAACE,KAAL,EAAY;IACVA,KAAK,GACHD,IAAI,KAAK,KAATA,IAAkBA,IAAI,KAAK,QAA3BA,GAAsC,OAAtCA,GACEA,IAAI,KAAK,OAATA,IAAoBA,IAAI,KAAK,KAA7BA,GAAqC,KAArCA,GACA,QAHJC;EAID;;EACD,OAAO;IACLD,IADK;IAELC;EAFK,CAAP;AAID;AAED;;AACA,OAAO,SAASE,cAAT,CAAyBJ,MAAzB,EAA+C;EACpD,OAAO;IACLC,IAAI,EAAE;MACJI,MAAM,EAAE,QADJ;MAEJC,GAAG,EAAE,QAFD;MAGJC,MAAM,EAAE,KAHJ;MAIJC,KAAK,EAAE,KAJH;MAKJC,GAAG,EAAE;IALD,EAMJT,MAAM,CAACC,IANH,CADD;IAQLC,KAAK,EAAEF,MAAM,CAACE;EART,CAAP;AAUD;AAED;;AACA,OAAO,SAASQ,cAAT,CAAyBV,MAAzB,EAA+CW,EAA/C,EAAgE;EAAA;;EACrE,MAAM;IAAEV,IAAF;IAAQC;EAAR,IAAkBF,MAAxB;EACA,MAAM;IAAEY;EAAF,IAAgBC,MAAM,CAACC,gBAAPD,CAAwBF,EAAxBE,CAAtB;EAEA,MAAME,GAAuC,GAAGH,SAAS,KAAK,KAAdA,GAAsB;IACpEJ,KAAK,EAAE,MAD6D;IAEpEC,GAAG,EAAE;EAF+D,CAAtBG,GAG5C;IACFJ,KAAK,EAAE,OADL;IAEFC,GAAG,EAAE;EAFH,CAHJ;EAQA,OAAO,cAACM,GAAG,CAACd,IAAD,CAAJ,wBAAcA,IAAd,IAAsB,GAAtB,kBAA6Bc,GAAG,CAACb,KAAD,CAAhC,yBAA2CA,KAA3C,CAAP;AACD","names":["block","inline","parseAnchor","anchor","side","align","split","oppositeAnchor","center","top","bottom","start","end","physicalAnchor","el","direction","window","getComputedStyle","map"],"sources":["../../../../src/components/VOverlay/util/anchor.ts"],"sourcesContent":["const block = ['top', 'bottom'] as const\nconst inline = ['start', 'end'] as const\ntype Tblock = typeof block[number]\ntype Tinline = typeof inline [number]\nexport type Anchor =\n  | Tblock\n  | Tinline\n  | 'center'\n  | 'center center'\n  | `${Tblock} ${Tinline | 'center'}`\n  | `${Tinline} ${Tblock | 'center'}`\nexport type ParsedAnchor =\n  | { side: 'center', align: 'center' }\n  | { side: Tblock, align: Tinline | 'center' }\n  | { side: Tinline, align: Tblock | 'center' }\n\n/** Parse a raw anchor string into an object */\nexport function parseAnchor (anchor: Anchor) {\n  let [side, align] = anchor.split(' ')\n  if (!align) {\n    align =\n      side === 'top' || side === 'bottom' ? 'start'\n      : side === 'start' || side === 'end' ? 'top'\n      : 'center'\n  }\n  return {\n    side,\n    align,\n  } as ParsedAnchor\n}\n\n/** Get an anchor directly opposite, with the same alignment */\nexport function oppositeAnchor (anchor: ParsedAnchor) {\n  return {\n    side: {\n      center: 'center',\n      top: 'bottom',\n      bottom: 'top',\n      start: 'end',\n      end: 'start',\n    }[anchor.side],\n    align: anchor.align,\n  } as ParsedAnchor\n}\n\n/** Convert start/end into left/right */\nexport function physicalAnchor (anchor: ParsedAnchor, el: HTMLElement) {\n  const { side, align } = anchor\n  const { direction } = window.getComputedStyle(el)\n\n  const map: Record<string, string | undefined> = direction === 'ltr' ? {\n    start: 'left',\n    end: 'right',\n  } : {\n    start: 'right',\n    end: 'left',\n  }\n\n  return (map[side] ?? side) + ' ' + (map[align] ?? align)\n}\n"]},"metadata":{},"sourceType":"module"}