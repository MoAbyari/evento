{"ast":null,"code":"import \"core-js/modules/es.array.includes.js\";\n// Utilities\nimport { computed, effectScope, nextTick, onScopeDispose, ref, watch, watchEffect } from 'vue';\nimport { convertToUnit, getScrollParent, IN_BROWSER, isFixedPosition, nullifyTransforms, propsFactory } from \"../../util/index.mjs\";\nimport { oppositeAnchor, parseAnchor, physicalAnchor } from \"./util/anchor.mjs\";\nimport { anchorToPoint, getOffset } from \"./util/point.mjs\"; // Types\n\nimport { Box } from \"../../util/box.mjs\";\nconst locationStrategies = {\n  static: staticLocationStrategy,\n  // specific viewport position, usually centered\n  connected: connectedLocationStrategy // connected to a certain element\n\n};\nexport const makeLocationStrategyProps = propsFactory({\n  locationStrategy: {\n    type: [String, Function],\n    default: 'static',\n    validator: val => typeof val === 'function' || val in locationStrategies\n  },\n  location: {\n    type: String,\n    default: 'bottom'\n  },\n  origin: {\n    type: String,\n    default: 'auto'\n  },\n  offset: [Number, String]\n});\nexport function useLocationStrategies(props, data) {\n  const contentStyles = ref({});\n  const updateLocation = ref();\n  let scope;\n  watchEffect(async () => {\n    var _scope;\n\n    (_scope = scope) == null ? void 0 : _scope.stop();\n    updateLocation.value = undefined;\n    if (!(IN_BROWSER && data.isActive.value && props.locationStrategy)) return;\n    scope = effectScope();\n    await nextTick();\n    scope.run(() => {\n      if (typeof props.locationStrategy === 'function') {\n        var _props$locationStrate;\n\n        updateLocation.value = (_props$locationStrate = props.locationStrategy(data, props, contentStyles)) == null ? void 0 : _props$locationStrate.updateLocation;\n      } else {\n        var _locationStrategies$p;\n\n        updateLocation.value = (_locationStrategies$p = locationStrategies[props.locationStrategy](data, props, contentStyles)) == null ? void 0 : _locationStrategies$p.updateLocation;\n      }\n    });\n  });\n  IN_BROWSER && window.addEventListener('resize', onResize, {\n    passive: true\n  });\n  onScopeDispose(() => {\n    var _scope2;\n\n    IN_BROWSER && window.removeEventListener('resize', onResize);\n    updateLocation.value = undefined;\n    (_scope2 = scope) == null ? void 0 : _scope2.stop();\n  });\n\n  function onResize(e) {\n    var _updateLocation$value;\n\n    (_updateLocation$value = updateLocation.value) == null ? void 0 : _updateLocation$value.call(updateLocation, e);\n  }\n\n  return {\n    contentStyles,\n    updateLocation\n  };\n}\n\nfunction staticLocationStrategy() {// TODO\n}\n\nfunction connectedLocationStrategy(data, props, contentStyles) {\n  const activatorFixed = isFixedPosition(data.activatorEl.value);\n\n  if (activatorFixed) {\n    Object.assign(contentStyles.value, {\n      position: 'fixed'\n    });\n  }\n\n  const preferredAnchor = computed(() => parseAnchor(props.location));\n  const preferredOrigin = computed(() => props.origin === 'overlap' ? preferredAnchor.value : props.origin === 'auto' ? oppositeAnchor(preferredAnchor.value) : parseAnchor(props.origin));\n  const doesOverlap = computed(() => {\n    return preferredAnchor.value.side === preferredOrigin.value.side;\n  });\n  const configuredMaxHeight = computed(() => {\n    const val = parseFloat(props.maxHeight);\n    return isNaN(val) ? Infinity : val;\n  });\n  const configuredMinWidth = computed(() => {\n    const val = parseFloat(props.minWidth);\n    return isNaN(val) ? Infinity : val;\n  });\n  let observe = false;\n\n  if (IN_BROWSER) {\n    const observer = new ResizeObserver(() => {\n      if (observe) updateLocation();\n    });\n    observer.observe(data.activatorEl.value);\n    observer.observe(data.contentEl.value);\n    onScopeDispose(() => {\n      observer.disconnect();\n    });\n  } // eslint-disable-next-line max-statements\n\n\n  function updateLocation() {\n    var _props$maxWidth;\n\n    observe = false;\n    requestAnimationFrame(() => {\n      requestAnimationFrame(() => observe = true);\n    });\n    const targetBox = data.activatorEl.value.getBoundingClientRect(); // TODO: offset shouldn't affect width\n\n    if (props.offset) {\n      targetBox.x -= +props.offset;\n      targetBox.y -= +props.offset;\n      targetBox.width += +props.offset * 2;\n      targetBox.height += +props.offset * 2;\n    }\n\n    const scrollParent = getScrollParent(data.contentEl.value);\n    const viewportWidth = scrollParent.clientWidth;\n    const viewportHeight = Math.min(scrollParent.clientHeight, window.innerHeight);\n    let contentBox;\n    {\n      const scrollables = new Map();\n      data.contentEl.value.querySelectorAll('*').forEach(el => {\n        const x = el.scrollLeft;\n        const y = el.scrollTop;\n\n        if (x || y) {\n          scrollables.set(el, [x, y]);\n        }\n      });\n      const initialMaxWidth = data.contentEl.value.style.maxWidth;\n      const initialMaxHeight = data.contentEl.value.style.maxHeight;\n      data.contentEl.value.style.removeProperty('max-width');\n      data.contentEl.value.style.removeProperty('max-height');\n      contentBox = nullifyTransforms(data.contentEl.value);\n      contentBox.x -= parseFloat(data.contentEl.value.style.left) || 0;\n      contentBox.y -= parseFloat(data.contentEl.value.style.top) || 0;\n      data.contentEl.value.style.maxWidth = initialMaxWidth;\n      data.contentEl.value.style.maxHeight = initialMaxHeight;\n      scrollables.forEach((position, el) => {\n        el.scrollTo(...position);\n      });\n    }\n    const contentHeight = Math.min(configuredMaxHeight.value, contentBox.height); // Regard undefined maxWidth as maximally occupying whole remaining space by default\n\n    const maxFreeSpaceWidth = props.maxWidth === undefined ? Number.MAX_VALUE : parseInt((_props$maxWidth = props.maxWidth) != null ? _props$maxWidth : 0, 10);\n    const viewportMargin = 12;\n    const freeSpace = {\n      top: targetBox.top - viewportMargin,\n      bottom: viewportHeight - targetBox.bottom - viewportMargin,\n      left: Math.min(targetBox.left - viewportMargin, maxFreeSpaceWidth),\n      right: Math.min(viewportWidth - targetBox.right - viewportMargin, maxFreeSpaceWidth)\n    };\n    const fitsY = preferredAnchor.value.side === 'bottom' && contentHeight <= freeSpace.bottom || preferredAnchor.value.side === 'top' && contentHeight <= freeSpace.top;\n    const anchor = fitsY ? preferredAnchor.value : preferredAnchor.value.side === 'bottom' && freeSpace.top > freeSpace.bottom || preferredAnchor.value.side === 'top' && freeSpace.bottom > freeSpace.top ? oppositeAnchor(preferredAnchor.value) : preferredAnchor.value;\n    const origin = fitsY ? preferredOrigin.value : oppositeAnchor(anchor);\n    const canFill = doesOverlap.value || ['center', 'top', 'bottom'].includes(anchor.side);\n    const maxWidth = canFill ? Math.min(viewportWidth, Math.max(targetBox.width, viewportWidth - viewportMargin * 2)) : anchor.side === 'end' ? freeSpace.right : anchor.side === 'start' ? freeSpace.left : null;\n    const minWidth = Math.min(configuredMinWidth.value, maxWidth, targetBox.width);\n    const maxHeight = fitsY ? configuredMaxHeight.value : Math.min(configuredMaxHeight.value, Math.floor(anchor.side === 'top' ? freeSpace.top : freeSpace.bottom));\n    const targetPoint = anchorToPoint(anchor, targetBox);\n    const contentPoint = anchorToPoint(origin, new Box({ ...contentBox,\n      height: Math.min(contentHeight, maxHeight)\n    }));\n    const {\n      x,\n      y\n    } = getOffset(targetPoint, contentPoint);\n    Object.assign(contentStyles.value, {\n      '--v-overlay-anchor-origin': physicalAnchor(anchor, data.activatorEl.value),\n      top: convertToUnit(Math.round(y)),\n      left: convertToUnit(Math.round(x)),\n      // TODO: right for origin=\"end\", rtl\n      transformOrigin: physicalAnchor(origin, data.activatorEl.value),\n      minWidth: convertToUnit(minWidth),\n      maxWidth: convertToUnit(maxWidth),\n      maxHeight: convertToUnit(maxHeight)\n    });\n  }\n\n  watch(() => [preferredAnchor.value, preferredOrigin.value, props.offset], () => updateLocation(), {\n    immediate: !activatorFixed\n  });\n  if (activatorFixed) nextTick(() => updateLocation());\n  requestAnimationFrame(() => {\n    if (contentStyles.value.maxHeight) updateLocation();\n  });\n  return {\n    updateLocation\n  };\n}","map":{"version":3,"mappings":"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","names":["computed","effectScope","nextTick","onScopeDispose","ref","watch","watchEffect","convertToUnit","getScrollParent","IN_BROWSER","isFixedPosition","nullifyTransforms","propsFactory","oppositeAnchor","parseAnchor","physicalAnchor","anchorToPoint","getOffset","Box","locationStrategies","static","staticLocationStrategy","connected","connectedLocationStrategy","makeLocationStrategyProps","locationStrategy","type","String","Function","default","validator","val","location","origin","offset","Number","useLocationStrategies","props","data","contentStyles","updateLocation","scope","stop","value","undefined","isActive","run","_props$locationStrate","_locationStrategies$p","window","addEventListener","onResize","passive","removeEventListener","e","activatorFixed","activatorEl","Object","assign","position","preferredAnchor","preferredOrigin","doesOverlap","side","configuredMaxHeight","parseFloat","maxHeight","isNaN","Infinity","configuredMinWidth","minWidth","observe","observer","ResizeObserver","contentEl","disconnect","requestAnimationFrame","targetBox","getBoundingClientRect","x","y","width","height","scrollParent","viewportWidth","clientWidth","viewportHeight","Math","min","clientHeight","innerHeight","contentBox","scrollables","Map","querySelectorAll","forEach","el","scrollLeft","scrollTop","set","initialMaxWidth","style","maxWidth","initialMaxHeight","removeProperty","left","top","scrollTo","contentHeight","maxFreeSpaceWidth","MAX_VALUE","parseInt","viewportMargin","freeSpace","bottom","right","fitsY","anchor","canFill","includes","max","floor","targetPoint","contentPoint","round","transformOrigin","immediate"],"sources":["../../../src/components/VOverlay/locationStrategies.ts"],"sourcesContent":["// Utilities\nimport { computed, effectScope, nextTick, onScopeDispose, ref, watch, watchEffect } from 'vue'\nimport { convertToUnit, getScrollParent, IN_BROWSER, isFixedPosition, nullifyTransforms, propsFactory } from '@/util'\nimport { oppositeAnchor, parseAnchor, physicalAnchor } from './util/anchor'\nimport { anchorToPoint, getOffset } from './util/point'\n\n// Types\nimport type { EffectScope, PropType, Ref } from 'vue'\nimport type { Anchor } from './util/anchor'\nimport { Box } from '@/util/box'\n\nexport interface LocationStrategyData {\n  contentEl: Ref<HTMLElement | undefined>\n  activatorEl: Ref<HTMLElement | undefined>\n  isActive: Ref<boolean>\n}\n\nconst locationStrategies = {\n  static: staticLocationStrategy, // specific viewport position, usually centered\n  connected: connectedLocationStrategy, // connected to a certain element\n}\n\nexport interface StrategyProps {\n  locationStrategy: keyof typeof locationStrategies | (\n    (\n      data: LocationStrategyData,\n      props: StrategyProps,\n      contentStyles: Ref<Record<string, string>>\n    ) => undefined | { updateLocation: (e: Event) => void }\n  )\n  location: Anchor\n  origin: Anchor | 'auto' | 'overlap'\n  offset?: number | string\n  maxHeight?: number | string\n  maxWidth?: number | string\n  minHeight?: number | string\n  minWidth?: number | string\n}\n\nexport const makeLocationStrategyProps = propsFactory({\n  locationStrategy: {\n    type: [String, Function] as PropType<StrategyProps['locationStrategy']>,\n    default: 'static',\n    validator: (val: any) => typeof val === 'function' || val in locationStrategies,\n  },\n  location: {\n    type: String as PropType<StrategyProps['location']>,\n    default: 'bottom',\n  },\n  origin: {\n    type: String as PropType<StrategyProps['origin']>,\n    default: 'auto',\n  },\n  offset: [Number, String],\n})\n\nexport function useLocationStrategies (\n  props: StrategyProps,\n  data: LocationStrategyData\n) {\n  const contentStyles = ref({})\n  const updateLocation = ref<(e: Event) => void>()\n\n  let scope: EffectScope | undefined\n  watchEffect(async () => {\n    scope?.stop()\n    updateLocation.value = undefined\n\n    if (!(IN_BROWSER && data.isActive.value && props.locationStrategy)) return\n\n    scope = effectScope()\n    await nextTick()\n    scope.run(() => {\n      if (typeof props.locationStrategy === 'function') {\n        updateLocation.value = props.locationStrategy(data, props, contentStyles)?.updateLocation\n      } else {\n        updateLocation.value = locationStrategies[props.locationStrategy](data, props, contentStyles)?.updateLocation\n      }\n    })\n  })\n\n  IN_BROWSER && window.addEventListener('resize', onResize, { passive: true })\n\n  onScopeDispose(() => {\n    IN_BROWSER && window.removeEventListener('resize', onResize)\n    updateLocation.value = undefined\n    scope?.stop()\n  })\n\n  function onResize (e: Event) {\n    updateLocation.value?.(e)\n  }\n\n  return {\n    contentStyles,\n    updateLocation,\n  }\n}\n\nfunction staticLocationStrategy () {\n  // TODO\n}\n\nfunction connectedLocationStrategy (data: LocationStrategyData, props: StrategyProps, contentStyles: Ref<Record<string, string>>) {\n  const activatorFixed = isFixedPosition(data.activatorEl.value)\n  if (activatorFixed) {\n    Object.assign(contentStyles.value, {\n      position: 'fixed',\n    })\n  }\n\n  const preferredAnchor = computed(() => parseAnchor(props.location))\n  const preferredOrigin = computed(() =>\n    props.origin === 'overlap' ? preferredAnchor.value\n    : props.origin === 'auto' ? oppositeAnchor(preferredAnchor.value)\n    : parseAnchor(props.origin)\n  )\n  const doesOverlap = computed(() => {\n    return preferredAnchor.value.side === preferredOrigin.value.side\n  })\n\n  const configuredMaxHeight = computed(() => {\n    const val = parseFloat(props.maxHeight!)\n    return isNaN(val) ? Infinity : val\n  })\n\n  const configuredMinWidth = computed(() => {\n    const val = parseFloat(props.minWidth!)\n    return isNaN(val) ? Infinity : val\n  })\n\n  let observe = false\n  if (IN_BROWSER) {\n    const observer = new ResizeObserver(() => {\n      if (observe) updateLocation()\n    })\n    observer.observe(data.activatorEl.value!)\n    observer.observe(data.contentEl.value!)\n\n    onScopeDispose(() => {\n      observer.disconnect()\n    })\n  }\n\n  // eslint-disable-next-line max-statements\n  function updateLocation () {\n    observe = false\n    requestAnimationFrame(() => {\n      requestAnimationFrame(() => observe = true)\n    })\n\n    const targetBox = data.activatorEl.value!.getBoundingClientRect()\n    // TODO: offset shouldn't affect width\n    if (props.offset) {\n      targetBox.x -= +props.offset\n      targetBox.y -= +props.offset\n      targetBox.width += +props.offset * 2\n      targetBox.height += +props.offset * 2\n    }\n\n    const scrollParent = getScrollParent(data.contentEl.value)\n    const viewportWidth = scrollParent.clientWidth\n    const viewportHeight = Math.min(scrollParent.clientHeight, window.innerHeight)\n\n    let contentBox\n    {\n      const scrollables = new Map<Element, [number, number]>()\n      data.contentEl.value!.querySelectorAll('*').forEach(el => {\n        const x = el.scrollLeft\n        const y = el.scrollTop\n        if (x || y) {\n          scrollables.set(el, [x, y])\n        }\n      })\n\n      const initialMaxWidth = data.contentEl.value!.style.maxWidth\n      const initialMaxHeight = data.contentEl.value!.style.maxHeight\n      data.contentEl.value!.style.removeProperty('max-width')\n      data.contentEl.value!.style.removeProperty('max-height')\n\n      contentBox = nullifyTransforms(data.contentEl.value!)\n      contentBox.x -= parseFloat(data.contentEl.value!.style.left) || 0\n      contentBox.y -= parseFloat(data.contentEl.value!.style.top) || 0\n\n      data.contentEl.value!.style.maxWidth = initialMaxWidth\n      data.contentEl.value!.style.maxHeight = initialMaxHeight\n      scrollables.forEach((position, el) => {\n        el.scrollTo(...position)\n      })\n    }\n\n    const contentHeight = Math.min(configuredMaxHeight.value, contentBox.height)\n\n    // Regard undefined maxWidth as maximally occupying whole remaining space by default\n    const maxFreeSpaceWidth = props.maxWidth === undefined ? Number.MAX_VALUE : parseInt(props.maxWidth ?? 0, 10)\n\n    const viewportMargin = 12\n    const freeSpace = {\n      top: targetBox.top - viewportMargin,\n      bottom: viewportHeight - targetBox.bottom - viewportMargin,\n      left: Math.min(targetBox.left - viewportMargin, maxFreeSpaceWidth),\n      right: Math.min(viewportWidth - targetBox.right - viewportMargin, maxFreeSpaceWidth),\n    }\n\n    const fitsY = (preferredAnchor.value.side === 'bottom' && contentHeight <= freeSpace.bottom) ||\n      (preferredAnchor.value.side === 'top' && contentHeight <= freeSpace.top)\n\n    const anchor = fitsY ? preferredAnchor.value\n      : (preferredAnchor.value.side === 'bottom' && freeSpace.top > freeSpace.bottom) ||\n      (preferredAnchor.value.side === 'top' && freeSpace.bottom > freeSpace.top) ? oppositeAnchor(preferredAnchor.value)\n      : preferredAnchor.value\n    const origin = fitsY ? preferredOrigin.value : oppositeAnchor(anchor)\n\n    const canFill = doesOverlap.value || ['center', 'top', 'bottom'].includes(anchor.side)\n\n    const maxWidth = canFill ? Math.min(viewportWidth, Math.max(targetBox.width, viewportWidth - viewportMargin * 2))\n      : anchor.side === 'end' ? freeSpace.right\n      : anchor.side === 'start' ? freeSpace.left\n      : null\n    const minWidth = Math.min(configuredMinWidth.value, maxWidth!, targetBox.width)\n    const maxHeight = fitsY ? configuredMaxHeight.value : Math.min(\n      configuredMaxHeight.value,\n      Math.floor(anchor.side === 'top' ? freeSpace.top : freeSpace.bottom)\n    )\n\n    const targetPoint = anchorToPoint(anchor, targetBox)\n    const contentPoint = anchorToPoint(origin, new Box({\n      ...contentBox,\n      height: Math.min(contentHeight, maxHeight),\n    }))\n\n    const { x, y } = getOffset(targetPoint, contentPoint)\n\n    Object.assign(contentStyles.value, {\n      '--v-overlay-anchor-origin': physicalAnchor(anchor, data.activatorEl.value!),\n      top: convertToUnit(Math.round(y)),\n      left: convertToUnit(Math.round(x)), // TODO: right for origin=\"end\", rtl\n      transformOrigin: physicalAnchor(origin, data.activatorEl.value!),\n      minWidth: convertToUnit(minWidth),\n      maxWidth: convertToUnit(maxWidth),\n      maxHeight: convertToUnit(maxHeight),\n    })\n  }\n\n  watch(\n    () => [preferredAnchor.value, preferredOrigin.value, props.offset],\n    () => updateLocation(),\n    { immediate: !activatorFixed }\n  )\n\n  if (activatorFixed) nextTick(() => updateLocation())\n  requestAnimationFrame(() => {\n    if (contentStyles.value.maxHeight) updateLocation()\n  })\n\n  return { updateLocation }\n}\n"]},"metadata":{},"sourceType":"module"}